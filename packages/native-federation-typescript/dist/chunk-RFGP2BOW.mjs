var B=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});import O from"ansi-colors";import{resolve as U}from"node:path";import{mergeDeepRight as j}from"rambda";import{createUnplugin as D}from"unplugin";var z={typesFolder:"@mf-types",deleteTypesFolder:!0,maxRetries:3},k=t=>{let e=t.split("@");return e[e.length-1]},C="file:",W=(t,e)=>{let r=k(e),o=new URL(r,C),s=o.pathname.split("/").slice(0,-1).join("/");return o.pathname=`${s}/${t.typesFolder}.zip`,o.protocol===C?o.pathname:o.href},Z=t=>Object.entries(t.moduleFederationConfig.remotes).reduce((e,[r,o])=>(e[r]=W(t,o),e),{}),F=t=>{if(!t.moduleFederationConfig)throw new Error("moduleFederationConfig is required");let e={...z,...t},r=Z(e);return{hostOptions:e,mapRemotesToDownload:r}};import{existsSync as M}from"fs";import{dirname as V,join as u,resolve as X}from"path";import m from"typescript";var J={tsConfigPath:"./tsconfig.json",typesFolder:"@mf-types",compiledTypesFolder:"compiled-types",deleteTypesFolder:!0,additionalFilesToCompile:[],compilerInstance:"tsc"},G=({tsConfigPath:t,typesFolder:e,compiledTypesFolder:r})=>{let o=X(t),s=m.readConfigFile(o,m.sys.readFile),i=m.parseJsonConfigFileContent(s.config,m.sys,V(o)),n=u(i.options.outDir||"dist",e,r);return{...i.options,emitDeclarationOnly:!0,noEmit:!1,declaration:!0,outDir:n}},K=["ts","tsx","vue","svelte"],w=t=>{let e=process.cwd();for(let r of K){let o=u(e,`${t}.${r}`);if(M(o))return o}},Q=t=>Object.entries(t.moduleFederationConfig.exposes).reduce((e,[r,o])=>(e[r]=w(o)||w(u(o,"index"))||o,e),{}),x=t=>{if(!t.moduleFederationConfig)throw new Error("moduleFederationConfig is required");let e={...J,...t},r=Q(e);return{tsConfig:G(e),mapComponentsToExpose:r,remoteOptions:e}};import H from"adm-zip";import $ from"ansi-colors";import ce from"axios";import{createHash as ae}from"node:crypto";import{rm as me}from"node:fs/promises";import{join as q}from"node:path";import E from"ansi-colors";import{dirname as Y,join as ee,normalize as d,relative as te,sep as re}from"path";import l from"typescript";var oe=/^\//,P=".d.ts",se=t=>{let{line:e}=t.file.getLineAndCharacterOfPosition(t.start);console.error(E.red(`TS Error ${t.code}':' ${l.flattenDiagnosticMessageText(t.messageText,l.sys.newLine)}`)),console.error(E.red(`         at ${t.file.fileName}:${e+1} typescript.sys.newLine`))},a=(t,e)=>d(t.outDir.replace(e.compiledTypesFolder,"")),g=(t,e)=>d(t.outDir.replace(e.compiledTypesFolder,"").replace(e.typesFolder,"")),ie=(t,e,r)=>{let o=l.createCompilerHost(e),s=o.writeFile,i=Object.fromEntries(Object.entries(t).map(([p,c])=>[d(c),p])),n=a(e,r);return o.writeFile=(p,c,f,I,R,L)=>{s(p,c,f,I,R,L);for(let A of R||[]){let h=i[d(A.fileName)];if(h){let v=ee(n,`${h}${P}`),_=Y(v),T=te(_,p).replace(P,"").replace(oe,"").split(re).join("/");s(v,`export * from './${T}';
export { default } from './${T}';`,f)}}},o},ne=t=>B("vue-tsc").createProgram(t),pe=(t,e)=>{switch(t.compilerInstance){case"vue-tsc":return ne(e);case"tsc":default:return l.createProgram(e)}},S=(t,e,r)=>{let o=ie(t,e,r),i={rootNames:[...Object.values(t),...r.additionalFilesToCompile],host:o,options:e},n=pe(r,i),{diagnostics:p=[]}=n.emit();p.forEach(se)};var de=(t,e)=>q(t.replace(e.typesFolder,""),`${e.typesFolder}.zip`),b=async(t,e)=>{let r=a(t,e),o=new H;return o.addLocalFolder(r),o.writeZipPromise(de(r,e))},le=(t,e)=>r=>{throw{...r,message:`Network error: Unable to download federated mocks for '${t}' from '${e}' because '${r.message}'`}},y=async(t,e)=>{t.deleteTypesFolder&&await me(e,{recursive:!0,force:!0}).catch(r=>console.error($.red(`Unable to remove types folder, ${r}`)))},N=t=>{let e={},r={};return async([o,s])=>{e[s]=0;let i=q(t.typesFolder,o);for(;e[s]++<t.maxRetries;)try{let n=await ce.get(s,{responseType:"arraybuffer"}).catch(le(o,s)),p=Buffer.from(n.data),c=ae("sha256").update(p).digest("hex");r[s]!==c&&(await y(t,i),new H(p).extractAllTo(i,!0),r[s]=c);break}catch(n){if(console.error($.red(`Error during types archive download: ${(n==null?void 0:n.message)||"unknown error"}`)),e[s]>=t.maxRetries)throw n}}};var _e=D(t=>{let{remoteOptions:e,tsConfig:r,mapComponentsToExpose:o}=x(t),s=a(r,e);return{name:"native-federation-typescript/remote",async writeBundle(){try{S(o,r,e),await b(r,e),await y(e,s),console.log(O.green("Federated types created correctly"))}catch(i){console.error(O.red(`Unable to compile federated types, ${i}`))}},get vite(){return process.env.NODE_ENV==="production"?void 0:{buildStart:this.writeBundle,watchChange:this.writeBundle}},webpack(i){i.options.devServer=j(i.options.devServer||{},{static:{directory:U(g(r,e))}})},rspack(i){i.options.devServer=j(i.options.devServer||{},{static:{directory:U(g(r,e))}})}}}),Be=D(t=>{let{hostOptions:e,mapRemotesToDownload:r}=F(t),o=N(e);return{name:"native-federation-typescript/host",async writeBundle(){let s=Object.entries(r).map(o);await Promise.allSettled(s),console.log(O.green("Federated types extraction completed"))},get vite(){return process.env.NODE_ENV==="production"?void 0:{buildStart:this.writeBundle,watchChange:this.writeBundle}}}});export{_e as a,Be as b};
